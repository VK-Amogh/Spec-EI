-- ==============================================================================
-- SpecEI Complete Database Schema v2.0
-- Combined from all SQL files with FIXED RLS policies
-- Run this in Supabase SQL Editor to set up the complete database
-- ==============================================================================

-- ==============================================================================
-- 1. TABLES
-- ==============================================================================

-- 1.1 Users Table
CREATE TABLE IF NOT EXISTS public.users (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    firebase_uid TEXT UNIQUE NOT NULL,
    email TEXT UNIQUE NOT NULL,
    full_name TEXT NOT NULL,
    phone_number TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Ensure columns exist (for existing tables)
DO $$ 
BEGIN 
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'phone_number') THEN 
        ALTER TABLE public.users ADD COLUMN phone_number TEXT;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'created_at') THEN 
        ALTER TABLE public.users ADD COLUMN created_at TIMESTAMPTZ DEFAULT NOW();
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'updated_at') THEN 
        ALTER TABLE public.users ADD COLUMN updated_at TIMESTAMPTZ DEFAULT NOW();
    END IF;
END $$;

-- 1.2 Pending Verifications Table
CREATE TABLE IF NOT EXISTS public.pending_verifications (
    email TEXT PRIMARY KEY,
    email_verified BOOLEAN DEFAULT FALSE,
    phone_verified BOOLEAN DEFAULT FALSE,
    phone_number TEXT,
    verified_at TIMESTAMPTZ DEFAULT NOW()
);

-- 1.3 Password Resets Table
CREATE TABLE IF NOT EXISTS public.password_resets (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    identifier TEXT NOT NULL,
    email TEXT,
    phone_number TEXT,
    type TEXT NOT NULL,
    code TEXT NOT NULL,
    requested_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    is_verified BOOLEAN DEFAULT FALSE
);

-- 1.4 Reminders Table
CREATE TABLE IF NOT EXISTS public.reminders (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id TEXT NOT NULL,
    title TEXT NOT NULL,
    reminder_datetime TIMESTAMPTZ NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    is_completed BOOLEAN DEFAULT FALSE
);

-- 1.5 Notes Table
CREATE TABLE IF NOT EXISTS public.notes (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id TEXT NOT NULL,
    title TEXT NOT NULL,
    content TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 1.6 Focus Sessions Table
CREATE TABLE IF NOT EXISTS public.focus_sessions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id TEXT NOT NULL,
    duration_minutes INTEGER NOT NULL,
    session_type TEXT DEFAULT 'timed',
    started_at TIMESTAMPTZ DEFAULT NOW(),
    ended_at TIMESTAMPTZ,
    actual_minutes INTEGER,
    is_completed BOOLEAN DEFAULT FALSE
);

-- 1.7 Media Table
CREATE TABLE IF NOT EXISTS public.media (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id TEXT NOT NULL,
    media_type TEXT NOT NULL CHECK (media_type IN ('photo', 'video', 'audio')),
    file_path TEXT,
    file_url TEXT,
    file_name TEXT,
    transcription TEXT,
    duration_seconds INTEGER,
    ai_description TEXT,
    captured_at TIMESTAMPTZ DEFAULT NOW(),
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Add columns if they don't exist (for existing media tables)
DO $$ 
BEGIN 
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'media' AND column_name = 'file_name') THEN 
        ALTER TABLE public.media ADD COLUMN file_name TEXT;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'media' AND column_name = 'transcription') THEN 
        ALTER TABLE public.media ADD COLUMN transcription TEXT;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'media' AND column_name = 'ai_description') THEN 
        ALTER TABLE public.media ADD COLUMN ai_description TEXT;
    END IF;
END $$;

-- 1.8 Transcripts Table (Memory System)
CREATE TABLE IF NOT EXISTS public.transcripts (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    media_id UUID REFERENCES public.media(id) ON DELETE CASCADE,
    language TEXT DEFAULT 'en',
    full_text TEXT NOT NULL,
    confidence FLOAT,
    word_count INTEGER,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 1.9 Events Table (Memory System)
CREATE TABLE IF NOT EXISTS public.events (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id TEXT NOT NULL,
    title TEXT NOT NULL,
    summary TEXT,
    start_time TIMESTAMPTZ NOT NULL,
    end_time TIMESTAMPTZ,
    event_type TEXT CHECK (event_type IN ('conversation', 'activity', 'scene', 'memory')),
    importance INTEGER DEFAULT 5 CHECK (importance BETWEEN 1 AND 10),
    location TEXT,
    tags TEXT[],
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 1.10 Event-Media Junction Table
CREATE TABLE IF NOT EXISTS public.event_media (
    event_id UUID REFERENCES public.events(id) ON DELETE CASCADE,
    media_id UUID REFERENCES public.media(id) ON DELETE CASCADE,
    role TEXT DEFAULT 'primary',
    created_at TIMESTAMPTZ DEFAULT NOW(),
    PRIMARY KEY (event_id, media_id)
);

-- 1.11 Detected Objects Table
CREATE TABLE IF NOT EXISTS public.detected_objects (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    media_id UUID REFERENCES public.media(id) ON DELETE CASCADE,
    object_type TEXT NOT NULL CHECK (object_type IN ('person', 'object', 'text', 'place', 'animal', 'brand', 'activity')),
    label TEXT NOT NULL,
    confidence FLOAT,
    bounding_box JSONB,
    timestamp_seconds FLOAT,
    metadata JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- ==============================================================================
-- 2. INDEXES
-- ==============================================================================

-- Users Indexes
CREATE INDEX IF NOT EXISTS idx_users_firebase_uid ON public.users(firebase_uid);
CREATE INDEX IF NOT EXISTS idx_users_email ON public.users(email);
CREATE INDEX IF NOT EXISTS idx_users_phone_number ON public.users(phone_number);

-- Password Resets Indexes
CREATE INDEX IF NOT EXISTS idx_password_resets_identifier_code ON public.password_resets(identifier, code);

-- Reminders Indexes
CREATE INDEX IF NOT EXISTS idx_reminders_user ON public.reminders(user_id);
CREATE INDEX IF NOT EXISTS idx_reminders_datetime ON public.reminders(reminder_datetime);

-- Notes Indexes
CREATE INDEX IF NOT EXISTS idx_notes_user ON public.notes(user_id);
CREATE INDEX IF NOT EXISTS idx_notes_created ON public.notes(created_at);

-- Focus Sessions Indexes
CREATE INDEX IF NOT EXISTS idx_focus_user ON public.focus_sessions(user_id);

-- Media Indexes
CREATE INDEX IF NOT EXISTS idx_media_user ON public.media(user_id);
CREATE INDEX IF NOT EXISTS idx_media_type ON public.media(media_type);
CREATE INDEX IF NOT EXISTS idx_media_ai_description ON public.media USING gin(to_tsvector('english', COALESCE(ai_description, '')));

-- Transcripts Indexes
CREATE INDEX IF NOT EXISTS idx_transcripts_media ON public.transcripts(media_id);
CREATE INDEX IF NOT EXISTS idx_transcripts_fulltext ON public.transcripts USING gin(to_tsvector('english', full_text));

-- Events Indexes
CREATE INDEX IF NOT EXISTS idx_events_user ON public.events(user_id);
CREATE INDEX IF NOT EXISTS idx_events_time ON public.events(start_time);
CREATE INDEX IF NOT EXISTS idx_events_type ON public.events(event_type);
CREATE INDEX IF NOT EXISTS idx_events_summary ON public.events USING gin(to_tsvector('english', COALESCE(summary, '')));

-- Detected Objects Indexes
CREATE INDEX IF NOT EXISTS idx_detected_objects_media ON public.detected_objects(media_id);
CREATE INDEX IF NOT EXISTS idx_detected_objects_type ON public.detected_objects(object_type);
CREATE INDEX IF NOT EXISTS idx_detected_objects_label ON public.detected_objects(label);

-- ==============================================================================
-- 3. FUNCTIONS & TRIGGERS
-- ==============================================================================

-- Function to link auth identifiers
CREATE OR REPLACE FUNCTION public.link_auth_identifiers()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.email IS NULL AND NEW.type = 'phone' THEN
        SELECT email INTO NEW.email FROM public.users WHERE phone_number = NEW.identifier;
    END IF;
    IF NEW.phone_number IS NULL AND NEW.type = 'email' THEN
        SELECT phone_number INTO NEW.phone_number FROM public.users WHERE email = NEW.identifier;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_link_auth_identifiers ON public.password_resets;
CREATE TRIGGER trg_link_auth_identifiers
BEFORE INSERT ON public.password_resets
FOR EACH ROW
EXECUTE FUNCTION public.link_auth_identifiers();

-- ==============================================================================
-- 4. RPC FUNCTIONS (Secure Operations)
-- ==============================================================================

-- Check email exists (case-insensitive)
CREATE OR REPLACE FUNCTION public.check_email_exists(email_to_check text)
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  RETURN EXISTS (SELECT 1 FROM public.users WHERE email ILIKE email_to_check);
END;
$$;
GRANT EXECUTE ON FUNCTION public.check_email_exists(text) TO anon, authenticated, service_role;

-- Create user profile
CREATE OR REPLACE FUNCTION public.create_user_profile(
    p_firebase_uid TEXT,
    p_email TEXT,
    p_full_name TEXT,
    p_phone_number TEXT DEFAULT NULL
)
RETURNS VOID
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
    INSERT INTO public.users (firebase_uid, email, full_name, phone_number, updated_at)
    VALUES (p_firebase_uid, p_email, p_full_name, p_phone_number, NOW())
    ON CONFLICT (firebase_uid) 
    DO UPDATE SET 
        email = EXCLUDED.email,
        full_name = EXCLUDED.full_name,
        phone_number = COALESCE(EXCLUDED.phone_number, public.users.phone_number),
        updated_at = NOW();
END;
$$;
GRANT EXECUTE ON FUNCTION public.create_user_profile(TEXT, TEXT, TEXT, TEXT) TO anon, authenticated, service_role;

-- Get user profile
CREATE OR REPLACE FUNCTION public.get_user_profile(p_firebase_uid TEXT)
RETURNS SETOF public.users
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
    RETURN QUERY SELECT * FROM public.users WHERE firebase_uid = p_firebase_uid;
END;
$$;
GRANT EXECUTE ON FUNCTION public.get_user_profile(TEXT) TO anon, authenticated, service_role;

-- Save media
CREATE OR REPLACE FUNCTION public.save_media(
    p_user_id TEXT,
    p_media_type TEXT,
    p_file_path TEXT,
    p_file_url TEXT,
    p_file_name TEXT DEFAULT NULL,
    p_transcription TEXT DEFAULT NULL,
    p_duration_seconds INTEGER DEFAULT NULL
)
RETURNS SETOF public.media
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
    RETURN QUERY
    INSERT INTO public.media (
        user_id, media_type, file_path, file_url, file_name, transcription, duration_seconds, captured_at, created_at
    )
    VALUES (
        p_user_id, p_media_type, p_file_path, p_file_url, p_file_name, p_transcription, p_duration_seconds, NOW(), NOW()
    )
    RETURNING *;
END;
$$;
GRANT EXECUTE ON FUNCTION public.save_media(TEXT, TEXT, TEXT, TEXT, TEXT, TEXT, INTEGER) TO anon, authenticated, service_role;

-- Get media secure
CREATE OR REPLACE FUNCTION get_media_secure(p_user_id text)
RETURNS SETOF media
LANGUAGE sql
SECURITY DEFINER
SET search_path = public
AS $$
  SELECT *
  FROM media
  WHERE user_id = p_user_id
  ORDER BY captured_at DESC;
$$;
GRANT EXECUTE ON FUNCTION get_media_secure(text) TO anon, authenticated, service_role;

-- Delete media
CREATE OR REPLACE FUNCTION public.delete_media(p_media_id UUID)
RETURNS VOID
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
    DELETE FROM public.media WHERE id = p_media_id;
END;
$$;
GRANT EXECUTE ON FUNCTION public.delete_media(UUID) TO anon, authenticated, service_role;

-- Save transcript
CREATE OR REPLACE FUNCTION public.save_transcript(
    p_media_id UUID,
    p_full_text TEXT,
    p_language TEXT DEFAULT 'en',
    p_confidence FLOAT DEFAULT NULL
)
RETURNS SETOF public.transcripts
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
    v_word_count INTEGER;
BEGIN
    v_word_count := array_length(string_to_array(trim(p_full_text), ' '), 1);
    RETURN QUERY
    INSERT INTO public.transcripts (media_id, full_text, language, confidence, word_count)
    VALUES (p_media_id, p_full_text, p_language, p_confidence, v_word_count)
    ON CONFLICT DO NOTHING
    RETURNING *;
END;
$$;
GRANT EXECUTE ON FUNCTION public.save_transcript(UUID, TEXT, TEXT, FLOAT) TO anon, authenticated, service_role;

-- Search memory
CREATE OR REPLACE FUNCTION public.search_memory(
    p_user_id TEXT,
    p_query TEXT
)
RETURNS TABLE (
    media_id UUID,
    media_type TEXT,
    file_url TEXT,
    match_source TEXT,
    match_text TEXT,
    relevance FLOAT
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
    v_tsquery tsquery;
BEGIN
    v_tsquery := plainto_tsquery('english', p_query);
    
    RETURN QUERY
    SELECT 
        m.id as media_id,
        m.media_type,
        m.file_url,
        'ai_description'::TEXT as match_source,
        m.ai_description as match_text,
        ts_rank(to_tsvector('english', COALESCE(m.ai_description, '')), v_tsquery)::FLOAT as relevance
    FROM public.media m
    WHERE m.user_id = p_user_id
      AND m.ai_description IS NOT NULL
      AND to_tsvector('english', m.ai_description) @@ v_tsquery
    
    UNION ALL
    
    SELECT 
        t.media_id,
        m.media_type,
        m.file_url,
        'transcript'::TEXT as match_source,
        t.full_text as match_text,
        ts_rank(to_tsvector('english', t.full_text), v_tsquery)::FLOAT as relevance
    FROM public.transcripts t
    JOIN public.media m ON m.id = t.media_id
    WHERE m.user_id = p_user_id
      AND to_tsvector('english', t.full_text) @@ v_tsquery
    
    UNION ALL
    
    SELECT 
        d.media_id,
        m.media_type,
        m.file_url,
        'detected_object'::TEXT as match_source,
        d.label as match_text,
        ts_rank(to_tsvector('english', d.label), v_tsquery)::FLOAT as relevance
    FROM public.detected_objects d
    JOIN public.media m ON m.id = d.media_id
    WHERE m.user_id = p_user_id
      AND to_tsvector('english', d.label) @@ v_tsquery
    
    ORDER BY relevance DESC
    LIMIT 50;
END;
$$;
GRANT EXECUTE ON FUNCTION public.search_memory(TEXT, TEXT) TO anon, authenticated, service_role;

-- ==============================================================================
-- 5. ROW LEVEL SECURITY (RLS) - FIXED POLICIES
-- ==============================================================================

-- Enable RLS on all tables
ALTER TABLE public.users ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.pending_verifications ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.password_resets ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.reminders ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.notes ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.focus_sessions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.media ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.transcripts ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.events ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.event_media ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.detected_objects ENABLE ROW LEVEL SECURITY;

-- ============================================================
-- USERS TABLE POLICIES (CRITICAL FIX!)
-- ============================================================
DROP POLICY IF EXISTS "Allow read access" ON public.users;
DROP POLICY IF EXISTS "Allow insert access" ON public.users;
DROP POLICY IF EXISTS "Allow update access" ON public.users;
DROP POLICY IF EXISTS "users_read_public" ON public.users;
DROP POLICY IF EXISTS "users_read_own" ON public.users;
DROP POLICY IF EXISTS "users_write_auth" ON public.users;
DROP POLICY IF EXISTS "users_insert_auth" ON public.users;
DROP POLICY IF EXISTS "users_update_own" ON public.users;
DROP POLICY IF EXISTS "users_public_all" ON public.users;

-- FIXED: Create policies that allow all operations for users table
-- (App uses Firebase Auth + RPC functions, so we need public access)
CREATE POLICY "users_public_all" ON public.users FOR ALL USING (true) WITH CHECK (true);

-- ============================================================
-- PENDING VERIFICATIONS POLICIES
-- ============================================================
DROP POLICY IF EXISTS "verifications_public_all" ON public.pending_verifications;
CREATE POLICY "verifications_public_all" ON public.pending_verifications FOR ALL USING (true) WITH CHECK (true);

-- ============================================================
-- PASSWORD RESETS POLICIES
-- ============================================================
DROP POLICY IF EXISTS "Enable all for public" ON public.password_resets;
DROP POLICY IF EXISTS "pwd_resets_public" ON public.password_resets;
CREATE POLICY "pwd_resets_public" ON public.password_resets FOR ALL USING (true) WITH CHECK (true);

-- ============================================================
-- REMINDERS POLICIES
-- ============================================================
DROP POLICY IF EXISTS "Users can manage their own reminders" ON public.reminders;
DROP POLICY IF EXISTS "Allow insert for all" ON public.reminders;
DROP POLICY IF EXISTS "Allow select for all" ON public.reminders;
DROP POLICY IF EXISTS "Allow update for all" ON public.reminders;
DROP POLICY IF EXISTS "Allow delete for all" ON public.reminders;
DROP POLICY IF EXISTS "Allow all access reminders" ON public.reminders;
DROP POLICY IF EXISTS "reminders_public" ON public.reminders;
CREATE POLICY "reminders_public" ON public.reminders FOR ALL USING (true) WITH CHECK (true);

-- ============================================================
-- NOTES POLICIES
-- ============================================================
DROP POLICY IF EXISTS "Allow insert notes" ON public.notes;
DROP POLICY IF EXISTS "Allow select notes" ON public.notes;
DROP POLICY IF EXISTS "Allow update notes" ON public.notes;
DROP POLICY IF EXISTS "Allow delete notes" ON public.notes;
DROP POLICY IF EXISTS "Allow all access notes" ON public.notes;
DROP POLICY IF EXISTS "notes_public" ON public.notes;
CREATE POLICY "notes_public" ON public.notes FOR ALL USING (true) WITH CHECK (true);

-- ============================================================
-- FOCUS SESSIONS POLICIES
-- ============================================================
DROP POLICY IF EXISTS "Allow insert focus" ON public.focus_sessions;
DROP POLICY IF EXISTS "Allow select focus" ON public.focus_sessions;
DROP POLICY IF EXISTS "Allow update focus" ON public.focus_sessions;
DROP POLICY IF EXISTS "Allow delete focus" ON public.focus_sessions;
DROP POLICY IF EXISTS "Allow all access focus_sessions" ON public.focus_sessions;
DROP POLICY IF EXISTS "focus_sessions_public" ON public.focus_sessions;
CREATE POLICY "focus_sessions_public" ON public.focus_sessions FOR ALL USING (true) WITH CHECK (true);

-- ============================================================
-- MEDIA POLICIES
-- ============================================================
DROP POLICY IF EXISTS "Allow insert media" ON public.media;
DROP POLICY IF EXISTS "Allow select media" ON public.media;
DROP POLICY IF EXISTS "Allow update media" ON public.media;
DROP POLICY IF EXISTS "Allow delete media" ON public.media;
DROP POLICY IF EXISTS "Allow all access media" ON public.media;
DROP POLICY IF EXISTS "media_select_public" ON public.media;
DROP POLICY IF EXISTS "media_public_all" ON public.media;
DROP POLICY IF EXISTS "media_public" ON public.media;
CREATE POLICY "media_public" ON public.media FOR ALL USING (true) WITH CHECK (true);

-- ============================================================
-- MEMORY SYSTEM POLICIES
-- ============================================================
DROP POLICY IF EXISTS "transcripts_public" ON public.transcripts;
CREATE POLICY "transcripts_public" ON public.transcripts FOR ALL USING (true) WITH CHECK (true);

DROP POLICY IF EXISTS "events_public" ON public.events;
CREATE POLICY "events_public" ON public.events FOR ALL USING (true) WITH CHECK (true);

DROP POLICY IF EXISTS "event_media_public" ON public.event_media;
CREATE POLICY "event_media_public" ON public.event_media FOR ALL USING (true) WITH CHECK (true);

DROP POLICY IF EXISTS "detected_objects_public" ON public.detected_objects;
CREATE POLICY "detected_objects_public" ON public.detected_objects FOR ALL USING (true) WITH CHECK (true);

-- ==============================================================================
-- 6. STORAGE CONFIGURATION (Manual Step Required)
-- ==============================================================================
-- NOTE: Go to Supabase Dashboard -> Storage and:
-- 1. Create a public bucket named 'media-files'
-- 2. Add policy: Allow Public Read/Write/Delete for all users

-- ==============================================================================
-- DONE! Database schema is complete with all tables, functions, and policies.
-- ==============================================================================
