-- ==============================================================================
-- SpecEI Unified Database Schema
-- Combined & Cleaned from: supabase_migrations.sql, supabase_schema.sql, supabase_tables.sql
-- ==============================================================================

-- ------------------------------------------------------------------------------
-- 1. TABLES
-- ------------------------------------------------------------------------------

-- 1.1 Users Table
CREATE TABLE IF NOT EXISTS public.users (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    firebase_uid TEXT UNIQUE NOT NULL,
    email TEXT UNIQUE NOT NULL,
    full_name TEXT NOT NULL,
    phone_number TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Ensure columns exist (for existing tables)
DO $$ 
BEGIN 
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'phone_number') THEN 
        ALTER TABLE public.users ADD COLUMN phone_number TEXT;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'created_at') THEN 
        ALTER TABLE public.users ADD COLUMN created_at TIMESTAMPTZ DEFAULT NOW();
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'updated_at') THEN 
        ALTER TABLE public.users ADD COLUMN updated_at TIMESTAMPTZ DEFAULT NOW();
    END IF;
END $$;

-- 1.2 Password Resets Table
CREATE TABLE IF NOT EXISTS public.password_resets (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    identifier TEXT NOT NULL,
    email TEXT,
    phone_number TEXT,
    type TEXT NOT NULL,
    code TEXT NOT NULL,
    requested_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    is_verified BOOLEAN DEFAULT FALSE
);

-- 1.3 Reminders Table
CREATE TABLE IF NOT EXISTS public.reminders (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id TEXT NOT NULL,
    title TEXT NOT NULL,
    reminder_datetime TIMESTAMPTZ NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    is_completed BOOLEAN DEFAULT FALSE
);

-- 1.4 Notes Table
CREATE TABLE IF NOT EXISTS public.notes (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id TEXT NOT NULL,
    title TEXT NOT NULL,
    content TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 1.5 Focus Sessions Table
CREATE TABLE IF NOT EXISTS public.focus_sessions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id TEXT NOT NULL,
    duration_minutes INTEGER NOT NULL,
    session_type TEXT DEFAULT 'timed',
    started_at TIMESTAMPTZ DEFAULT NOW(),
    ended_at TIMESTAMPTZ,
    actual_minutes INTEGER,
    is_completed BOOLEAN DEFAULT FALSE
);

-- 1.6 Media Table
CREATE TABLE IF NOT EXISTS public.media (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id TEXT NOT NULL,
    media_type TEXT NOT NULL CHECK (media_type IN ('photo', 'video', 'audio')),
    file_path TEXT,
    file_url TEXT,
    duration_seconds INTEGER,
    captured_at TIMESTAMPTZ DEFAULT NOW(),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    ai_description TEXT -- Consolidated column addition here
);

-- ------------------------------------------------------------------------------
-- 2. INDEXES
-- ------------------------------------------------------------------------------

-- Users Indexes
CREATE INDEX IF NOT EXISTS idx_users_firebase_uid ON public.users(firebase_uid);
CREATE INDEX IF NOT EXISTS idx_users_email ON public.users(email);
CREATE INDEX IF NOT EXISTS idx_users_phone_number ON public.users(phone_number);

-- Password Resets Indexes
CREATE INDEX IF NOT EXISTS idx_password_resets_identifier_code ON public.password_resets(identifier, code);

-- Reminders Indexes
CREATE INDEX IF NOT EXISTS idx_reminders_user ON public.reminders(user_id);
CREATE INDEX IF NOT EXISTS idx_reminders_datetime ON public.reminders(reminder_datetime);

-- Notes Indexes
CREATE INDEX IF NOT EXISTS idx_notes_user ON public.notes(user_id);
CREATE INDEX IF NOT EXISTS idx_notes_created ON public.notes(created_at);

-- Focus Sessions Indexes
CREATE INDEX IF NOT EXISTS idx_focus_user ON public.focus_sessions(user_id);

-- Media Indexes
CREATE INDEX IF NOT EXISTS idx_media_user ON public.media(user_id);
CREATE INDEX IF NOT EXISTS idx_media_type ON public.media(media_type);
CREATE INDEX IF NOT EXISTS idx_media_ai_description ON public.media USING gin(to_tsvector('english', COALESCE(ai_description, '')));

-- ------------------------------------------------------------------------------
-- 3. FUNCTIONS & TRIGGERS
-- ------------------------------------------------------------------------------

-- Function to automatically link email and phone (Password Resets)
CREATE OR REPLACE FUNCTION public.link_auth_identifiers()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.email IS NULL AND NEW.type = 'phone' THEN
        SELECT email INTO NEW.email FROM public.users WHERE phone_number = NEW.identifier;
    END IF;
    IF NEW.phone_number IS NULL AND NEW.type = 'email' THEN
        SELECT phone_number INTO NEW.phone_number FROM public.users WHERE email = NEW.identifier;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger for linking auth identifiers
DROP TRIGGER IF EXISTS trg_link_auth_identifiers ON public.password_resets;
CREATE TRIGGER trg_link_auth_identifiers
BEFORE INSERT ON public.password_resets
FOR EACH ROW
EXECUTE FUNCTION public.link_auth_identifiers();

-- ==============================================================================
-- SECURE EMAIL CHECK (RPC)
-- ==============================================================================
-- Allows checking if an email exists without exposing the users table to public read.
CREATE OR REPLACE FUNCTION public.check_email_exists(email_to_check text)
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER -- Runs with admin privileges to bypass RLS
SET search_path = public -- Secure search path
AS $$
BEGIN
  RETURN EXISTS (SELECT 1 FROM public.users WHERE email = email_to_check);
END;
$$;

-- Grant access to this function for anonymous and authenticated users
GRANT EXECUTE ON FUNCTION public.check_email_exists(text) TO anon, authenticated, service_role;

-- ==============================================================================
-- SECURE PROFILE CREATION (RPC)
-- ==============================================================================
-- Allows creating/updating user profile without giving public INSERT access to users table.
CREATE OR REPLACE FUNCTION public.create_user_profile(
    p_firebase_uid TEXT,
    p_email TEXT,
    p_full_name TEXT,
    p_phone_number TEXT DEFAULT NULL
)
RETURNS VOID
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
    INSERT INTO public.users (firebase_uid, email, full_name, phone_number, updated_at)
    VALUES (p_firebase_uid, p_email, p_full_name, p_phone_number, NOW())
    ON CONFLICT (firebase_uid) 
    DO UPDATE SET 
        email = EXCLUDED.email,
        full_name = EXCLUDED.full_name,
        phone_number = COALESCE(EXCLUDED.phone_number, public.users.phone_number),
        updated_at = NOW();
END;
$$;

GRANT EXECUTE ON FUNCTION public.create_user_profile(TEXT, TEXT, TEXT, TEXT) TO anon, authenticated, service_role;

-- ==============================================================================
-- SECURE PROFILE ACCESS (RPC)
-- ==============================================================================
CREATE OR REPLACE FUNCTION public.get_user_profile(p_firebase_uid TEXT)
RETURNS SETOF public.users
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
    RETURN QUERY SELECT * FROM public.users WHERE firebase_uid = p_firebase_uid;
END;
$$;

GRANT EXECUTE ON FUNCTION public.get_user_profile(TEXT) TO anon, authenticated, service_role;

-- ==============================================================================
-- SECURE MEDIA OPERATIONS (RPC)
-- ==============================================================================
-- Save media metadata securely
CREATE OR REPLACE FUNCTION public.save_media(
    p_user_id TEXT,
    p_media_type TEXT,
    p_file_path TEXT,
    p_file_url TEXT,
    p_file_name TEXT DEFAULT NULL,
    p_transcription TEXT DEFAULT NULL,
    p_duration_seconds INTEGER DEFAULT NULL
)
RETURNS SETOF public.media
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
    RETURN QUERY
    INSERT INTO public.media (
        user_id, media_type, file_path, file_url, file_name, transcription, duration_seconds, captured_at, created_at
    )
    VALUES (
        p_user_id, p_media_type, p_file_path, p_file_url, p_file_name, p_transcription, p_duration_seconds, NOW(), NOW()
    )
    RETURNING *;
END;
$$;

GRANT EXECUTE ON FUNCTION public.save_media(TEXT, TEXT, TEXT, TEXT, TEXT, TEXT, INTEGER) TO anon, authenticated, service_role;

-- Delete media safely 
CREATE OR REPLACE FUNCTION public.delete_media(p_media_id UUID)
RETURNS VOID
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
    DELETE FROM public.media WHERE id = p_media_id;
END;
$$;

GRANT EXECUTE ON FUNCTION public.delete_media(UUID) TO anon, authenticated, service_role;


-- Secure function to get media items items
-- Bypasses RLS for easier fetching from client
CREATE OR REPLACE FUNCTION get_media_secure(p_user_id text)
RETURNS SETOF media
LANGUAGE sql
SECURITY DEFINER
SET search_path = public
AS $$
  SELECT *
  FROM media
  WHERE user_id = p_user_id
  ORDER BY captured_at DESC;
$$;

GRANT EXECUTE ON FUNCTION get_media_secure(text) TO anon, authenticated, service_role;



-- ==============================================================================
-- 4. ROW LEVEL SECURITY (RLS) & POLICIES
-- ==============================================================================
-- Enable RLS on all tables
ALTER TABLE public.users           ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.password_resets ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.reminders       ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.notes           ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.focus_sessions  ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.media           ENABLE ROW LEVEL SECURITY;

-- Add pending_verifications table (was missing) and its RLS
CREATE TABLE IF NOT EXISTS public.pending_verifications (
    email TEXT PRIMARY KEY,
    email_verified BOOLEAN DEFAULT FALSE,
    phone_verified BOOLEAN DEFAULT FALSE,
    phone_number TEXT,
    verified_at TIMESTAMPTZ DEFAULT NOW()
);
ALTER TABLE public.pending_verifications ENABLE ROW LEVEL SECURITY;

-- Allow public access to verifications (needed for auth flow)
-- Ideally this should be tighter, but for now we follow the pattern
DROP POLICY IF EXISTS "verifications_public_all" ON public.pending_verifications;
CREATE POLICY "verifications_public_all" ON public.pending_verifications
    FOR ALL USING (true) WITH CHECK (true);


-- 4.1 Users – Hybrid Approach
-- Read: Via RPC `get_user_profile` preferred, but allow reading own row via UID check if signed in
-- Write: Via RPC `create_user_profile`.
DROP POLICY IF EXISTS "Allow read access" ON public.users;
DROP POLICY IF EXISTS "Allow insert access" ON public.users;
DROP POLICY IF EXISTS "Allow update access" ON public.users;
DROP POLICY IF EXISTS "users_read_public" ON public.users;
DROP POLICY IF EXISTS "users_read_own" ON public.users;
DROP POLICY IF EXISTS "users_write_auth" ON public.users;
DROP POLICY IF EXISTS "users_insert_auth" ON public.users;
DROP POLICY IF EXISTS "users_update_own" ON public.users;

-- 4.2 Password Resets – Public for flow
DROP POLICY IF EXISTS "Enable all for public" ON public.password_resets;
DROP POLICY IF EXISTS "pwd_resets_owner" ON public.password_resets;
DROP POLICY IF EXISTS "pwd_resets_public" ON public.password_resets; -- Added for idempotency
CREATE POLICY "pwd_resets_public" ON public.password_resets FOR ALL USING (true) WITH CHECK (true);

-- 4.3 App Data (Reminders, Notes, Focus, Media)
-- Since app uses Firebase Auth, Supabase sees 'anon'.
-- READ: Allow Public Select (Filtered by client query)
-- WRITE: Should ideally be RPC, but for simplicity we enable public Insert/Update too IF user handles it?
-- No, we stick to: READ = PUBLIC, WRITE = RPC (for Media) / PUBLIC (for others if RPC not ready).

-- Reminders
DROP POLICY IF EXISTS "reminders_owner" ON public.reminders;
DROP POLICY IF EXISTS "Allow all access reminders" ON public.reminders;
DROP POLICY IF EXISTS "Users can manage their own reminders" ON public.reminders;
DROP POLICY IF EXISTS "Allow insert for all" ON public.reminders;
DROP POLICY IF EXISTS "Allow select for all" ON public.reminders;
DROP POLICY IF EXISTS "Allow update for all" ON public.reminders;
DROP POLICY IF EXISTS "Allow delete for all" ON public.reminders;
DROP POLICY IF EXISTS "reminders_public" ON public.reminders; -- Added for idempotency
CREATE POLICY "reminders_public" ON public.reminders FOR ALL USING (true) WITH CHECK (true);

-- Notes
DROP POLICY IF EXISTS "notes_owner" ON public.notes;
DROP POLICY IF EXISTS "Allow all access notes" ON public.notes;
DROP POLICY IF EXISTS "notes_public" ON public.notes; -- Added for idempotency
CREATE POLICY "notes_public" ON public.notes FOR ALL USING (true) WITH CHECK (true);

-- Focus Sessions
DROP POLICY IF EXISTS "focus_sessions_owner" ON public.focus_sessions;
DROP POLICY IF EXISTS "Allow all access focus_sessions" ON public.focus_sessions;
DROP POLICY IF EXISTS "focus_sessions_public" ON public.focus_sessions; -- Added for idempotency
CREATE POLICY "focus_sessions_public" ON public.focus_sessions FOR ALL USING (true) WITH CHECK (true);

-- Media
DROP POLICY IF EXISTS "media_owner" ON public.media;
DROP POLICY IF EXISTS "Allow all access media" ON public.media;
-- READ: Public
DROP POLICY IF EXISTS "media_select_public" ON public.media; -- Added for idempotency
CREATE POLICY "media_select_public" ON public.media FOR SELECT USING (true);
-- WRITE: RPC preferred, but allow insert/update/delete via public policy for simplicity/compatibility 
-- if existing code relies on it and we haven't swapped ALL calls to RPC yet.
-- To be safe, we allow ALL for now, but we added RPC `save_media` for robust insertion.
DROP POLICY IF EXISTS "media_public_all" ON public.media; -- Added for idempotency
CREATE POLICY "media_public_all" ON public.media FOR ALL USING (true) WITH CHECK (true);


-- 4.2 Password Resets Policies
DROP POLICY IF EXISTS "Enable all for public" ON public.password_resets;
CREATE POLICY "Enable all for public" ON public.password_resets FOR ALL TO anon USING (true) WITH CHECK (true);

-- 4.3 Reminders Policies
-- Cleaning up: Replacing various overlapping policies with standard ones
DROP POLICY IF EXISTS "Users can manage their own reminders" ON public.reminders;
DROP POLICY IF EXISTS "Allow insert for all" ON public.reminders;
DROP POLICY IF EXISTS "Allow select for all" ON public.reminders;
DROP POLICY IF EXISTS "Allow update for all" ON public.reminders;
DROP POLICY IF EXISTS "Allow delete for all" ON public.reminders;
DROP POLICY IF EXISTS "Allow all access reminders" ON public.reminders;

CREATE POLICY "Allow all access reminders" ON public.reminders FOR ALL USING (true) WITH CHECK (true);

-- 4.4 Notes Policies
DROP POLICY IF EXISTS "Allow insert notes" ON public.notes;
DROP POLICY IF EXISTS "Allow select notes" ON public.notes;
DROP POLICY IF EXISTS "Allow update notes" ON public.notes;
DROP POLICY IF EXISTS "Allow delete notes" ON public.notes;
DROP POLICY IF EXISTS "Allow all access notes" ON public.notes;

CREATE POLICY "Allow all access notes" ON public.notes FOR ALL USING (true) WITH CHECK (true);

-- 4.5 Focus Sessions Policies
DROP POLICY IF EXISTS "Allow insert focus" ON public.focus_sessions;
DROP POLICY IF EXISTS "Allow select focus" ON public.focus_sessions;
DROP POLICY IF EXISTS "Allow update focus" ON public.focus_sessions;
DROP POLICY IF EXISTS "Allow delete focus" ON public.focus_sessions;
DROP POLICY IF EXISTS "Allow all access focus_sessions" ON public.focus_sessions;

CREATE POLICY "Allow all access focus_sessions" ON public.focus_sessions FOR ALL USING (true) WITH CHECK (true);

-- 4.6 Media Policies
DROP POLICY IF EXISTS "Allow insert media" ON public.media;
DROP POLICY IF EXISTS "Allow select media" ON public.media;
DROP POLICY IF EXISTS "Allow update media" ON public.media;
DROP POLICY IF EXISTS "Allow delete media" ON public.media;
DROP POLICY IF EXISTS "Allow all access media" ON public.media;

CREATE POLICY "Allow all access media" ON public.media FOR ALL USING (true) WITH CHECK (true);

-- ==============================================================================
-- 5. STORAGE CONFIGURATION (Manual Step Required)
-- ==============================================================================
-- NOTE: Storage policies cannot be reliably scripted due to permission restrictions.
-- Please go to Supabase Dashboard -> Storage and:
-- 1. Create a public bucket named 'media-files'.
-- 2. Add a policy to allow Public Read/Write/Delete for all users (since we use RPCs/Firebase).

